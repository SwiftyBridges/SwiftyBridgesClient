//
//  API.swift
//  API
//
//  Created by Stephen Kockentiedt on 17.09.21.
//

import Foundation

/// This is the base class for APIs generated by SwiftyBridges
open class API {
    private let baseRequest: URLRequest
    private let client: BridgeClient
    
    /// The continuations of the `AsyncStream` instances returned by `errors`
    private let errorContinuations = Continuations<Error>()
    
    /// Initializer to use if you want to have control over the request that is sent for an API call. This may be the case if you want to send custom HTTP headers.
    /// - Parameters:
    ///   - baseRequest: The request that is modified by SwiftyBridgesClient to create an API call. Must be configured with the server URL where the `APIRouter` is listening.
    ///   - client: Optionally provide this parameter if API call shall use a custom client. This may be the case if you want to use a custom `URLSession`.
    public init(baseRequest: URLRequest, client: BridgeClient = .shared) {
        self.baseRequest = baseRequest
        self.client = client
    }
    
    /// Method indirectly called by generated APIs to perform an API method call. It can provide hooks for additional features such as error handling.
    /// - Parameter call: The API method call generated by SwiftyBridges
    /// - Returns: The return value of the API method
    fileprivate func perform<Call: APIMethodCall>(_ call: Call) async throws -> Call.ReturnType {
        do {
            return try await client.perform(call, baseRequest: baseRequest)
        } catch {
            await errorContinuations.yield(error)
            throw error
        }
    }
}

extension API {
    /// Initializer to use if no special configuration is needed
    /// - Parameters:
    ///   - url: The server URL where the `APIRouter` is listening
    ///   - client: Optionally provide this parameter if API call shall use a custom client. This may be the case if you want to use a custom `URLSession`.
    public convenience init(url: URL, client: BridgeClient = .shared) {
        self.init(baseRequest: URLRequest(url: url), client: client)
    }
    
    /// Initializer to use if you want to provide a bearer token for authentication
    /// - Parameters:
    ///   - url: The server URL where the `APIRouter` is listening
    ///   - bearerToken: The string used as the bearer token of API method requests
    ///   - client: Optionally provide this parameter if API call shall use a custom client. This may be the case if you want to use a custom `URLSession`.
    public convenience init(url: URL, bearerToken: String, client: BridgeClient = .shared) {
        var request = URLRequest(url: url)
        request.addValue("Bearer \(bearerToken)", forHTTPHeaderField: "Authorization")
        self.init(baseRequest: request, client: client)
    }
}

extension API {
    /// An `AsyncSequence` with all errors that are encountered by API method calls of this API
    ///
    /// This property can be used as follows:
    /// ```swift
    /// Task { [errors = api.errors] in
    ///     for await error in errors {
    ///         handle(error)
    ///     }
    /// }
    /// ```
    public var errors: AsyncStream<Error> {
        AsyncStream { continuation in
            Task {
                await errorContinuations.add(continuation)
            }
        }
    }
}

/// Helper namespace only to be used by code generated by SwiftyBridges
public enum SwiftyBridgesAPIHelper {
    /// Helper method that calls `API.perform()`
    ///
    /// This method exists so that `API.perform()` can be `private` and does not appear as a suggestion in code completion on every generated API type
    /// - Parameters:
    ///   - api: The API to call `perform()` on
    ///   - call: The API method call generated by SwiftyBridges
    /// - Returns: The return value of the API method
    public static func performAPIMethodCall<Call: APIMethodCall>(api: API, call: Call) async throws -> Call.ReturnType {
        
        try await api.perform(call)
    }
}

/// Holds instances of `AsyncStream.Continuation` so that values can be provided to them
actor Continuations<Element> {
    private var continuationByID: [UUID: AsyncStream<Element>.Continuation] = [:]
    
    deinit {
        // Ensure that all `for await ... in ...` loops are left when this instance is deallocated:
        continuationByID.values.forEach { $0.finish() }
    }
    
    /// Add a continuation to this instance
    ///
    /// When the continuation is terminated, it is automatically finished an removed.
    /// - Parameter continuation: The continuation to be added
    /// - Returns: The ID that is used to reference the given continuation by this instance
    @discardableResult
    func add(_ continuation: AsyncStream<Element>.Continuation) -> UUID {
        let id = UUID()
        continuationByID[id] = continuation
        continuation.onTermination = { @Sendable [weak self] _ in
            guard let self = self else { return }
            Task {
                await self.finishAndRemove(continuationWithID: id)
            }
        }
        return id
    }
    
    /// Provide a value to all continuations held by this instance
    func yield(_ value: Element) {
        for continuation in continuationByID.values {
            continuation.yield(value)
        }
    }
    
    /// Finishes and removes the continuation with the given ID
    /// - Parameter id: The ID returned by `add()`
    private func finishAndRemove(continuationWithID id: UUID) {
        continuationByID[id]?.finish()
        continuationByID[id] = nil
    }
}
